//
//  CertificateValidatorTests.swift
//  Lutheran RadioTests
//
//  Created by Jari Lammi on 24.7.2025.
//

import XCTest
import Security
import CommonCrypto
@testable import Lutheran_Radio

final class CertificateValidatorTests: XCTestCase {
    var validator: CertificateValidator!
    
    override func setUp() {
        super.setUp()
        validator = CertificateValidator()
    }
    
    func testComputeCertificateHash_WithValidCertificateData_ReturnsCorrectHash() throws {
        // Arrange: Use a known certificate DER data and expected hash
        // Note: Replace with actual DER bytes from a test certificate
        // For example, a sample self-signed cert DER (base64 encoded or hex)
        let sampleDERHex = "3082049A30820440A003020102021100E930B9B39116EC4EACA3879AE4E5949A300A06082A8648CE3D0403023060310B300906035504061302474231183016060355040A130F5365637469676F204C696D69746564313730350603550403132E5365637469676F205075626C6963205365727665722041757468656E7469636174696F6E20434120445620453336301E170D3235303732363030303030305A170D3236303832363233353935395A301B3119301706035504030C102A2E6C7574686572616E2E726164696F3076301006072A8648CE3D020106052B8104002203620004EDCE723E7F6028BEE9E69918EDF65272F4892A02D993D3ADA8AF92344B40B0A4915CBFDF75BA92A0E7EB7B7908CC2CAEA048E6839523BACCDACF2A88559E7217A292B70352F92FCFFE9021404A2B4EB8F91FCC3769BB28465A103D93EFD9A938A3820301308202FD301F0603551D230418301680141799A804C16FE42D70A80A103D03D3E91AB82663301D0603551D0E0416041484C877CDA81E019B0729ACF36A39BE311D345DE8300E0603551D0F0101FF040403020780300C0603551D130101FF04023000301D0603551D250416301406082B0601050507030106082B0601050507030230490603551D20044230403034060B2B06010401B231010202073025302306082B06010505070201161768747470733A2F2F7365637469676F2E636F6D2F4350533008060667810C01020130818406082B0601050507010104783076304F06082B060105050730028643687474703A2F2F6372742E7365637469676F2E636F6D2F5365637469676F5075626C696353657276657241757468656E7469636174696F6E434144564533362E637274302306082B060105050730018617687474703A2F2F6F6373702E7365637469676F2E636F6D302B0603551D110424302282102A2E6C7574686572616E2E726164696F820E6C7574686572616E2E726164696F3082017D060A2B06010401D6790204020482016D048201690167007600D809553B944F7AFFC816196F944F85ABB0F8FC5E8755260F15D12E72BB454B140000019844E7E514000004030047304502206AF537160BAE9B72AC56DF02B6798E73F0BE56E7551E5111BF047178EFE9EB50022100B35B5DEFEB6BABA782C36FEC46DCD27B162BEA54576A59F4E45EBE2956DF224D007500ACAB30706CEBEC8431F413D2F4915F111E422443B1F2A68C4F3C2B3BA71E02C30000019844E7E4C1000004030046304402206A22037C4B4DC0FD696C1A7AAFF382D7ED85CC6A2B11234AB3303965FFD690680220338E179B27EBDA3A36495B34D6F5390C7AAF86B109ADA779E4B535CF01119496007600D76D7D10D1A7F577C2C7E95FD700BFF982C9335A65E1D0B3017317C0C8C569770000019844E7E4CD0000040300473045022100937715F6CF8C06EA4CF204E682E53F5F115F1C751AD4098B4A6DE50E96E8B95A0220522CBAD06E1DD9BCA11E4691494371C609E6CA7D7A6F686EF119DD362652751C300A06082A8648CE3D0403020348003045022100A16BC22945C764769D5EFB4589420198055CCF1DD1452B6A4D4790DBC92B4E8F02201F937D4DED44864655C9D1DC63A0C02E6E9830731495141ED11328D071D6AA7A"  // Full DER hex from openssl s_client -connect livestream.lutheran.radio:8443 -servername livestream.lutheran.radio < /dev/null | openssl x509 -outform der | xxd -p -c 0 | tr -d '\n'
        guard let sampleDERData = Data(hexString: sampleDERHex) else {
            XCTFail("Invalid test DER data")
            return
        }
        
        guard let certificate = SecCertificateCreateWithData(nil, sampleDERData as CFData) else {
            XCTFail("Failed to create SecCertificate from test data")
            return
        }
        
        let expectedHash = "CC:F7:8E:09:EF:F3:3D:9A:5D:8B:B0:5C:74:28:0D:F6:BE:14:1C:C4:47:F9:69:C2:90:2C:43:97:66:8B:3D:CC"  // Matches the pinned hash from CertificateValidator.swift
        
        // Act
        let computedHash = validator.computeCertificateHash(for: certificate)
        
        // Assert
        XCTAssertEqual(computedHash, expectedHash, "Computed hash should match expected value for known DER")
    }
    
    func testValidateCertificateChain_MatchingHash_ReturnsTrue() throws {
        // Arrange: Mock SecTrust with certificate that matches pinned hash
        let mockTrust = createMockSecTrust()
        
        // Act
        let isValid = validator.validateCertificateChain(serverTrust: mockTrust)
        
        // Assert
        XCTAssertTrue(isValid, "Should return true for matching hash")
    }
    
    func testValidateCertificateChain_NonMatchingHash_ReturnsFalse() throws {
        // Arrange: Use the top-level MismatchValidator subclass
        let mismatchValidator = MismatchValidator()
        let mockTrust = createMockSecTrust()
        
        // Act
        let isValid = mismatchValidator.validateCertificateChain(serverTrust: mockTrust)
        
        // Assert
        XCTAssertFalse(isValid, "Should return false for non-matching hash")
    }
    
    func testValidateServerTrust_DuringTransitionWithMismatch_ReturnsTrue() throws {
        // Arrange: Use the top-level MismatchValidator subclass and mock the date to be in transition period
        let mismatchValidator = MismatchValidator()
        mismatchValidator.currentDate = { CertificateValidator.transitionStartDate }
        let mockTrust = createMockSecTrust()
        let exp = expectation(description: "Completion called")
        var result: Bool?
        
        // Act
        mismatchValidator.validateServerTrust(mockTrust) { isValid in
            result = isValid
            exp.fulfill()
        }
        wait(for: [exp], timeout: 1.0)
        
        // Assert
        XCTAssertTrue(result ?? false, "Should return true during transition despite mismatch")
    }
    
    // Helper to create mock SecTrust
    private func createMockSecTrust() -> SecTrust {
        let sampleDERHex = "3082049A30820440A003020102021100E930B9B39116EC4EACA3879AE4E5949A300A06082A8648CE3D0403023060310B300906035504061302474231183016060355040A130F5365637469676F204C696D69746564313730350603550403132E5365637469676F205075626C6963205365727665722041757468656E7469636174696F6E20434120445620453336301E170D3235303732363030303030305A170D3236303832363233353935395A301B3119301706035504030C102A2E6C7574686572616E2E726164696F3076301006072A8648CE3D020106052B8104002203620004EDCE723E7F6028BEE9E69918EDF65272F4892A02D993D3ADA8AF92344B40B0A4915CBFDF75BA92A0E7EB7B7908CC2CAEA048E6839523BACCDACF2A88559E7217A292B70352F92FCFFE9021404A2B4EB8F91FCC3769BB28465A103D93EFD9A938A3820301308202FD301F0603551D230418301680141799A804C16FE42D70A80A103D03D3E91AB82663301D0603551D0E0416041484C877CDA81E019B0729ACF36A39BE311D345DE8300E0603551D0F0101FF040403020780300C0603551D130101FF04023000301D0603551D250416301406082B0601050507030106082B0601050507030230490603551D20044230403034060B2B06010401B231010202073025302306082B06010505070201161768747470733A2F2F7365637469676F2E636F6D2F4350533008060667810C01020130818406082B0601050507010104783076304F06082B060105050730028643687474703A2F2F6372742E7365637469676F2E636F6D2F5365637469676F5075626C696353657276657241757468656E7469636174696F6E434144564533362E637274302306082B060105050730018617687474703A2F2F6F6373702E7365637469676F2E636F6D302B0603551D110424302282102A2E6C7574686572616E2E726164696F820E6C7574686572616E2E726164696F3082017D060A2B06010401D6790204020482016D048201690167007600D809553B944F7AFFC816196F944F85ABB0F8FC5E8755260F15D12E72BB454B140000019844E7E514000004030047304502206AF537160BAE9B72AC56DF02B6798E73F0BE56E7551E5111BF047178EFE9EB50022100B35B5DEFEB6BABA782C36FEC46DCD27B162BEA54576A59F4E45EBE2956DF224D007500ACAB30706CEBEC8431F413D2F4915F111E422443B1F2A68C4F3C2B3BA71E02C30000019844E7E4C1000004030046304402206A22037C4B4DC0FD696C1A7AAFF382D7ED85CC6A2B11234AB3303965FFD690680220338E179B27EBDA3A36495B34D6F5390C7AAF86B109ADA779E4B535CF01119496007600D76D7D10D1A7F577C2C7E95FD700BFF982C9335A65E1D0B3017317C0C8C569770000019844E7E4CD0000040300473045022100937715F6CF8C06EA4CF204E682E53F5F115F1C751AD4098B4A6DE50E96E8B95A0220522CBAD06E1DD9BCA11E4691494371C609E6CA7D7A6F686EF119DD362652751C300A06082A8648CE3D0403020348003045022100A16BC22945C764769D5EFB4589420198055CCF1DD1452B6A4D4790DBC92B4E8F02201F937D4DED44864655C9D1DC63A0C02E6E9830731495141ED11328D071D6AA7A"  // Valid DER matching pinned hash
        guard let der = Data(hexString: sampleDERHex) else {
            XCTFail("Invalid DER data")
            fatalError()  // For test safety
        }
        guard let cert = SecCertificateCreateWithData(nil, der as CFData) else {
            XCTFail("Failed to create SecCertificate")
            fatalError()  // For test safety
        }
        let policy = SecPolicyCreateBasicX509()
        var trust: SecTrust?
        let createStatus = SecTrustCreateWithCertificates(cert, policy, &trust)
        guard createStatus == errSecSuccess, let mockTrust = trust else {
            XCTFail("Failed to create mock SecTrust: \(createStatus)")
            fatalError()  // For test safety
        }
        // Force trust evaluation to succeed by setting anchors
        SecTrustSetAnchorCertificates(mockTrust, [cert] as CFArray)
        return mockTrust
    }
    
    // Add more as needed
}

// Top-level subclass for testing mismatched hashes (shared across tests)
final class MismatchValidator: CertificateValidator, @unchecked Sendable {
    override var pinnedCertHash: String {
        "00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00"  // Invalid hash to force mismatch
    }
}

extension Data {
    init?(hexString: String) {
        // Implementation for hex to Data
        let len = hexString.count / 2
        var data = Data(capacity: len)
        var i = hexString.startIndex
        for _ in 0..<len {
            let j = hexString.index(i, offsetBy: 2)
            let bytes = hexString[i..<j]
            if var num = UInt8(bytes, radix: 16) {
                data.append(&num, count: 1)
            } else {
                return nil
            }
            i = j
        }
        self = data
    }
}
